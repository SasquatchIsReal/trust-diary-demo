import { noise } from "@chainsafe/libp2p-noise";
import { mplex } from "@libp2p/mplex";
import { webSockets } from "@libp2p/websockets";
import { all as filterAll } from "@libp2p/websockets/filters";
import { DefaultUserAgent, wakuFilter, wakuLightPush, wakuMetadata, WakuNode, wakuStore } from "@waku/core";
import { enrTree, wakuDnsDiscovery } from "@waku/dns-discovery";
import { wakuPeerExchangeDiscovery } from "@waku/peer-exchange";
import { wakuGossipSub, wakuRelay } from "@waku/relay";
import { createLibp2p } from "libp2p";
import { identifyService } from "libp2p/identify";
import { pingService } from "libp2p/ping";
const DEFAULT_NODE_REQUIREMENTS = {
    lightPush: 1,
    filter: 1,
    store: 1
};
const ensureShardingConfigured = (shardInfo) => {
    if (("shards" in shardInfo && shardInfo.shards.length < 1) ||
        ("contentTopics" in shardInfo && shardInfo.contentTopics.length < 1)) {
        throw new Error("Missing required configuration options for static sharding or autosharding.");
    }
};
/**
 * Create a Waku node configured to use autosharding or static sharding.
 */
export async function createNode(options) {
    options = options ?? {};
    if (!options.shardInfo) {
        throw new Error("Shard info must be set");
    }
    ensureShardingConfigured(options.shardInfo);
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(undefined, wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter = wakuFilter(options);
    return new WakuNode(options ?? {}, [], libp2p, options.shardInfo, store, lightPush, filter);
}
/**
 * Create a Waku node that uses Waku Light Push, Filter and Store to send and
 * receive messages, enabling low resource consumption.
 * Uses Waku Filter V2 by default.
 */
export async function createLightNode(options) {
    options = options ?? {};
    if (options.shardInfo) {
        ensureShardingConfigured(options.shardInfo);
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(options.shardInfo, wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter = wakuFilter(options);
    return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, options.shardInfo, store, lightPush, filter);
}
/**
 * Create a Waku node that uses Waku Relay to send and receive messages,
 * enabling some privacy preserving properties.
 */
export async function createRelayNode(options) {
    options = options ?? {};
    if (options.shardInfo) {
        ensureShardingConfigured(options.shardInfo);
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(options.shardInfo, wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const relay = wakuRelay(options);
    return new WakuNode(options, options.pubsubTopics, libp2p, options.shardInfo, undefined, undefined, undefined, relay);
}
/**
 * Create a Waku node that uses all Waku protocols.
 *
 * This helper is not recommended except if:
 * - you are interfacing with nwaku v0.11 or below
 * - you are doing some form of testing
 *
 * If you are building a full node, it is recommended to use
 * [nwaku](github.com/status-im/nwaku) and its JSON RPC API or wip REST API.
 *
 * @see https://github.com/status-im/nwaku/issues/1085
 * @internal
 */
export async function createFullNode(options) {
    options = options ?? {};
    if (options.shardInfo) {
        ensureShardingConfigured(options.shardInfo);
    }
    const libp2pOptions = options?.libp2p ?? {};
    const peerDiscovery = libp2pOptions.peerDiscovery ?? [];
    if (options?.defaultBootstrap) {
        peerDiscovery.push(...defaultPeerDiscoveries());
        Object.assign(libp2pOptions, { peerDiscovery });
    }
    const libp2p = await defaultLibp2p(options.shardInfo, wakuGossipSub(options), libp2pOptions, options?.userAgent);
    const store = wakuStore(options);
    const lightPush = wakuLightPush(options);
    const filter = wakuFilter(options);
    const relay = wakuRelay(options);
    return new WakuNode(options ?? {}, options.pubsubTopics, libp2p, options.shardInfo, store, lightPush, filter, relay);
}
export function defaultPeerDiscoveries() {
    const discoveries = [
        wakuDnsDiscovery([enrTree["PROD"]], DEFAULT_NODE_REQUIREMENTS),
        wakuPeerExchangeDiscovery()
    ];
    return discoveries;
}
export async function defaultLibp2p(shardInfo, wakuGossipSub, options, userAgent) {
    // Log the info log unless we are running tests or the user has disabled it
    if (!options?.hideWebSocketInfo || process.env.NODE_ENV !== "test") {
        /* eslint-disable no-console */
        console.info("%cIgnore WebSocket connection failures", "background: gray; color: white; font-size: x-large");
        console.info("%cWaku tries to discover peers and some of them are expected to fail", "background: gray; color: white; font-size: x-large");
        /* eslint-enable no-console */
    }
    const pubsubService = wakuGossipSub
        ? { pubsub: wakuGossipSub }
        : {};
    const metadataService = shardInfo
        ? { metadata: wakuMetadata(shardInfo) }
        : {};
    return createLibp2p({
        connectionManager: {
            minConnections: 1
        },
        transports: [webSockets({ filter: filterAll })],
        streamMuxers: [mplex()],
        connectionEncryption: [noise()],
        ...options,
        services: {
            identify: identifyService({
                agentVersion: userAgent ?? DefaultUserAgent
            }),
            ping: pingService(),
            ...metadataService,
            ...pubsubService,
            ...options?.services
        }
    }); // TODO: make libp2p include it;
}
//# sourceMappingURL=create.js.map