import { T as Tags } from './browser-mTOOnVZp.js';
import { k as bytesToUtf8, L as Logger, s as shardInfoToPubsubTopics, D as DefaultPubsubTopic } from './index-cmONXM-V.js';

/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
function selectRandomPeer(peers) {
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
/**
 * Returns the peer with the lowest latency.
 * @param peerStore - The Libp2p PeerStore
 * @param peers - The list of peers to choose from
 * @returns The peer with the lowest latency, or undefined if no peer could be reached
 */
async function selectLowestLatencyPeer(peerStore, peers) {
    if (peers.length === 0)
        return;
    const results = await Promise.all(peers.map(async (peer) => {
        const pingBytes = (await peerStore.get(peer.id)).metadata.get("ping");
        if (!pingBytes)
            return { peer, ping: Infinity };
        const ping = Number(bytesToUtf8(pingBytes)) ?? Infinity;
        return { peer, ping };
    }));
    const lowestLatencyResult = results.sort((a, b) => a.ping - b.ping)[0];
    if (!lowestLatencyResult) {
        return undefined;
    }
    return lowestLatencyResult.ping !== Infinity
        ? lowestLatencyResult.peer
        : undefined;
}
/**
 * Returns the list of peers that supports the given protocol.
 */
async function getPeersForProtocol(peerStore, protocols) {
    const peers = [];
    await peerStore.forEach((peer) => {
        for (let i = 0; i < protocols.length; i++) {
            if (peer.protocols.includes(protocols[i])) {
                peers.push(peer);
                break;
            }
        }
    });
    return peers;
}
async function getConnectedPeersForProtocol(connections, peerStore, protocols) {
    const openConnections = connections.filter((connection) => connection.status === "open");
    const peerPromises = openConnections.map(async (connection) => {
        const peer = await peerStore.get(connection.remotePeer);
        const supportsProtocol = peer.protocols.some((protocol) => protocols.includes(protocol));
        return supportsProtocol ? peer : null;
    });
    const peersWithNulls = await Promise.all(peerPromises);
    return peersWithNulls.filter((peer) => peer !== null);
}
/**
 * Returns a peer that supports the given protocol.
 * If peerId is provided, the peer with that id is returned.
 * Otherwise, the peer with the lowest latency is returned.
 * If no peer is found from the above criteria, a random peer is returned.
 */
async function selectPeerForProtocol(peerStore, protocols, peerId) {
    let peer;
    if (peerId) {
        peer = await peerStore.get(peerId);
        if (!peer) {
            throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toString()}`);
        }
    }
    else {
        const peers = await getPeersForProtocol(peerStore, protocols);
        peer = await selectLowestLatencyPeer(peerStore, peers);
        if (!peer) {
            peer = selectRandomPeer(peers);
            if (!peer)
                throw new Error(`Failed to find known peer that registers protocols: ${protocols}`);
        }
    }
    let protocol;
    for (const codec of protocols) {
        if (peer.protocols.includes(codec)) {
            protocol = codec;
            // Do not break as we want to keep the last value
        }
    }
    if (!protocol) {
        throw new Error(`Peer does not register required protocols (${peer.id.toString()}): ${protocols}`);
    }
    return { peer, protocol };
}
function selectConnection(connections) {
    if (!connections.length)
        return;
    if (connections.length === 1)
        return connections[0];
    let latestConnection;
    connections.forEach((connection) => {
        if (connection.status === "open") {
            if (!latestConnection) {
                latestConnection = connection;
            }
            else if (connection.timeline.open > latestConnection.timeline.open) {
                latestConnection = connection;
            }
        }
    });
    return latestConnection;
}

/**
 * Retrieves a list of peers based on the specified criteria.
 *
 * @param peers - The list of peers to filter from.
 * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
 * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
 * @returns A Promise that resolves to an array of peers based on the specified criteria.
 */
async function filterPeers(peers, numPeers, maxBootstrapPeers) {
    // Collect the bootstrap peers up to the specified maximum
    const bootstrapPeers = peers
        .filter((peer) => peer.tags.has(Tags.BOOTSTRAP))
        .slice(0, maxBootstrapPeers);
    // Collect non-bootstrap peers
    const nonBootstrapPeers = peers.filter((peer) => !peer.tags.has(Tags.BOOTSTRAP));
    // If numPeers is 0, return all peers
    if (numPeers === 0) {
        return [...bootstrapPeers, ...nonBootstrapPeers];
    }
    // Initialize the list of selected peers with the bootstrap peers
    const selectedPeers = [...bootstrapPeers];
    // Fill up to numPeers with remaining random peers if needed
    while (selectedPeers.length < numPeers && nonBootstrapPeers.length > 0) {
        const randomIndex = Math.floor(Math.random() * nonBootstrapPeers.length);
        const randomPeer = nonBootstrapPeers.splice(randomIndex, 1)[0];
        selectedPeers.push(randomPeer);
    }
    return selectedPeers;
}

class StreamManager {
    multicodec;
    getConnections;
    addEventListener;
    streamPool;
    log;
    constructor(multicodec, getConnections, addEventListener) {
        this.multicodec = multicodec;
        this.getConnections = getConnections;
        this.addEventListener = addEventListener;
        this.log = new Logger(`stream-manager:${multicodec}`);
        this.addEventListener("peer:update", this.handlePeerUpdateStreamPool.bind(this));
        this.getStream = this.getStream.bind(this);
        this.streamPool = new Map();
    }
    async getStream(peer) {
        const peerIdStr = peer.id.toString();
        const streamPromise = this.streamPool.get(peerIdStr);
        if (!streamPromise) {
            return this.newStream(peer); // fallback by creating a new stream on the spot
        }
        // We have the stream, let's remove it from the map
        this.streamPool.delete(peerIdStr);
        this.prepareNewStream(peer);
        const stream = await streamPromise;
        if (!stream || stream.status === "closed") {
            return this.newStream(peer); // fallback by creating a new stream on the spot
        }
        return stream;
    }
    async newStream(peer) {
        const connections = this.getConnections(peer.id);
        const connection = selectConnection(connections);
        if (!connection) {
            throw new Error("Failed to get a connection to the peer");
        }
        return connection.newStream(this.multicodec);
    }
    prepareNewStream(peer) {
        const streamPromise = this.newStream(peer).catch(() => {
            // No error thrown as this call is not triggered by the user
            this.log.error(`Failed to prepare a new stream for ${peer.id.toString()}`);
        });
        this.streamPool.set(peer.id.toString(), streamPromise);
    }
    handlePeerUpdateStreamPool = (evt) => {
        const peer = evt.detail.peer;
        if (peer.protocols.includes(this.multicodec)) {
            this.log.info(`Preemptively opening a stream to ${peer.id.toString()}`);
            this.prepareNewStream(peer);
        }
    };
}

/**
 * A class with predefined helpers, to be used as a base to implement Waku
 * Protocols.
 */
class BaseProtocol {
    multicodec;
    components;
    addLibp2pEventListener;
    removeLibp2pEventListener;
    streamManager;
    constructor(multicodec, components) {
        this.multicodec = multicodec;
        this.components = components;
        this.addLibp2pEventListener = components.events.addEventListener.bind(components.events);
        this.removeLibp2pEventListener = components.events.removeEventListener.bind(components.events);
        this.streamManager = new StreamManager(multicodec, components.connectionManager.getConnections.bind(components.connectionManager), this.addLibp2pEventListener);
    }
    async getStream(peer) {
        return this.streamManager.getStream(peer);
    }
    get peerStore() {
        return this.components.peerStore;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * the class protocol. Waku may or may not be currently connected to these
     * peers.
     */
    async peers() {
        return getPeersForProtocol(this.peerStore, [this.multicodec]);
    }
    async getPeer(peerId) {
        const { peer } = await selectPeerForProtocol(this.peerStore, [this.multicodec], peerId);
        return peer;
    }
    /**
     * Retrieves a list of connected peers based on the specified criteria.
     *
     * @param numPeers - The total number of peers to retrieve. If 0, all peers are returned.
     * @param maxBootstrapPeers - The maximum number of bootstrap peers to retrieve.
     * @returns A Promise that resolves to an array of peers based on the specified criteria.
     */
    async getPeers({ numPeers, maxBootstrapPeers } = {
        maxBootstrapPeers: 1,
        numPeers: 0
    }) {
        // Retrieve all connected peers that support the protocol
        const allPeersForProtocol = await getConnectedPeersForProtocol(this.components.connectionManager.getConnections(), this.peerStore, [this.multicodec]);
        // Filter the peers based on the specified criteria
        return filterPeers(allPeersForProtocol, numPeers, maxBootstrapPeers);
    }
    initializePubsubTopic(options) {
        return (options?.pubsubTopics ??
            (options?.shardInfo
                ? shardInfoToPubsubTopics(options.shardInfo)
                : [DefaultPubsubTopic]));
    }
}

export { BaseProtocol as B, StreamManager as S };
