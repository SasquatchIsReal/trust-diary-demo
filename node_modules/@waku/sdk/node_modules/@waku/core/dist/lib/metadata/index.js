import { encodeRelayShard } from "@waku/enr";
import { proto_metadata } from "@waku/proto";
import { Logger } from "@waku/utils";
import all from "it-all";
import * as lp from "it-length-prefixed";
import { pipe } from "it-pipe";
import { Uint8ArrayList } from "uint8arraylist";
import { BaseProtocol } from "../base_protocol.js";
const log = new Logger("metadata");
export const MetadataCodec = "/vac/waku/metadata/1.0.0";
class Metadata extends BaseProtocol {
    shardInfo;
    libp2pComponents;
    constructor(shardInfo, libp2p) {
        super(MetadataCodec, libp2p.components);
        this.libp2pComponents = libp2p;
        this.shardInfo = shardInfo;
        void libp2p.registrar.handle(MetadataCodec, (streamData) => {
            void this.onRequest(streamData);
        });
    }
    /**
     * Handle an incoming metadata request
     */
    async onRequest(streamData) {
        try {
            const { stream, connection } = streamData;
            const encodedShardInfo = proto_metadata.WakuMetadataResponse.encode(this.shardInfo);
            const encodedResponse = await pipe([encodedShardInfo], lp.encode, stream, lp.decode, async (source) => await all(source));
            const remoteShardInfoResponse = this.decodeMetadataResponse(encodedResponse);
            // add or update the shardInfo to peer store
            await this.libp2pComponents.peerStore.merge(connection.remotePeer, {
                metadata: {
                    shardInfo: encodeRelayShard(remoteShardInfoResponse)
                }
            });
        }
        catch (error) {
            log.error("Error handling metadata request", error);
        }
    }
    /**
     * Make a metadata query to a peer
     */
    async query(peerId) {
        const request = proto_metadata.WakuMetadataRequest.encode(this.shardInfo);
        const peer = await this.getPeer(peerId);
        const stream = await this.getStream(peer);
        const encodedResponse = await pipe([request], lp.encode, stream, lp.decode, async (source) => await all(source));
        const decodedResponse = this.decodeMetadataResponse(encodedResponse);
        return decodedResponse;
    }
    decodeMetadataResponse(encodedResponse) {
        const bytes = new Uint8ArrayList();
        encodedResponse.forEach((chunk) => {
            bytes.append(chunk);
        });
        const response = proto_metadata.WakuMetadataResponse.decode(bytes);
        if (!response)
            log.error("Error decoding metadata response");
        return response;
    }
}
export function wakuMetadata(shardInfo) {
    return (components) => new Metadata(shardInfo, components);
}
//# sourceMappingURL=index.js.map